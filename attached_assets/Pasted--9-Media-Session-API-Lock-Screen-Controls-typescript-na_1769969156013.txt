### 9. Media Session API (Lock Screen Controls)

```typescript
navigator.mediaSession.metadata = new MediaMetadata({
  title: track.title,
  artist: track.artist,
  album: 'Pod Brief',
  artwork: track.artwork ? [
    { src: track.artwork, sizes: '512x512', type: 'image/jpeg' },
  ] : [
    { src: '/icon-192.png', sizes: '192x192', type: 'image/png' },
    { src: '/icon-512.png', sizes: '512x512', type: 'image/png' },
  ],
});

// Action handlers
navigator.mediaSession.setActionHandler('play', ...);
navigator.mediaSession.setActionHandler('pause', ...);
navigator.mediaSession.setActionHandler('seekbackward', () => seek(-15));
navigator.mediaSession.setActionHandler('seekforward', () => seek(+15));
navigator.mediaSession.setActionHandler('seekto', (details) => ...);
```

---

### 10. iOS Recovery Logic

```typescript
// Stall recovery (audio suspended by OS)
audio.addEventListener('stalled', async () => {
  const savedPosition = audio.currentTime;
  audio.load();
  await waitForCanPlay(audio, 5000);
  audio.currentTime = savedPosition;
  audio.playbackRate = speed;
  await audio.play();
});

// Visibility change sync (returning from background)
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    if (state === 'playing' && audio.paused) {
      setState('paused'); // Sync UI with actual state
    }
  }
});

// Media session play handler (lock screen resume)
navigator.mediaSession.setActionHandler('play', async () => {
  if (audio.readyState < 2 && audio.src) {
    // iOS may have suspended - reload
    const savedPosition = audio.currentTime;
    audio.load();
    await waitForCanPlay(audio, 5000);
    audio.currentTime = savedPosition;
    audio.playbackRate = speed;
  }
  await audio.play();
});
```

---

### 11. Engagement Tracking

```typescript
const START_THRESHOLD_SECONDS = 30;     // Log "start" after 30s accumulated listening
const COMPLETION_THRESHOLD_PERCENT = 75; // Log "completion" at 75% progress

// Track accumulated listening (forward progress only)
if (playbackState === 'playing') {
  const delta = currentTime - lastTimeUpdate;
  if (delta > 0 && delta < 2) { // Only forward, reasonable jumps
    accumulatedListenTime += delta;
  }
}

// Insert to audio_engagement_events table
await supabase.from('audio_engagement_events').insert({
  user_id: user.id,
  master_brief_id: masterBriefId,
  audio_type: 'summary' | 'full_episode',
  event_type: 'start' | 'completion',
  duration_seconds: Math.round(audioDuration),
  progress_seconds: Math.round(currentPosition),
  progress_percentage: Math.round(progressPercent * 100) / 100,
});
```

---

### 12. Auto-Advance (Queue)

```typescript
// On track end, auto-play next in queue
audio.addEventListener('ended', async () => {
  // 1. Mark current as completed in database
  await supabase.from('user_briefs').update({ is_completed: true })...

  // 2. Get next track BEFORE queue refreshes
  const nextTrack = queueContext.getNextTrack();

  // 3. Refresh queue in background
  queueContext.refreshQueue();

  // 4. Play next (with browser visibility check)
  if (nextTrack && document.visibilityState === 'visible') {
    setTimeout(() => playTrackFromQueue(nextTrack), 500);
  } else if (nextTrack) {
    // Store for when user returns to foreground
    pendingAutoAdvance = { track: nextTrack, timestamp: Date.now() };
  }
});
```

---

### Key Differences for Native Mobile

| Web PWA | Native Mobile |
|---------|---------------|
| Uses `HTMLAudioElement` singleton | Use native audio APIs (AVAudioPlayer, ExoPlayer) |
| IndexedDB for caching | `AsyncStorage` + `expo-file-system` |
| `navigator.mediaSession` for lock screen | Native Now Playing / MediaSession APIs |
| Visibility API for background detection | Native app lifecycle events |
| Signed URLs expire (15 min) | Same - must refresh before download |
| Progress in `localStorage` | `AsyncStorage` or SQLite |

---

Let me know if you need more details on any specific part!

Update Mobile API Contract with audio player specs
Create audio player test checklist
Add combined track metadata endpoint

