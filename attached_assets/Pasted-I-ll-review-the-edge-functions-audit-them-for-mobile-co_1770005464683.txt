I'll review the edge functions, audit them for mobile compatibility, and update the documentation. Let me start by checking what's already documented and review the key edge functions.

Now I have the full picture. The documentation is already comprehensive - the mobile app just isn't following it correctly. Let me add an **Audit Findings & Required Fixes** section to the Mobile_Integration_Guide.md.

 **Last Audit:** February 2, 2026  \\n> **Repository:** https://github.com/victorkung/PodBrief-Mobile-App\\n\\nThis section documents implementation gaps identified during code review, compared against the web implementation and this documentation.\\n\\n---\\n\\n### ðŸ”´ Critical: Missing Audio Analytics Tracking\\n\\n**File:** `client/contexts/AudioPlayerContext.tsx`\\n\\n**Problem:** The mobile app does NOT track engagement events (`start`, `completion`) to `audio_engagement_events` table. This breaks analytics dashboards and user engagement metrics.\\n\\n**Required Implementation:**\\n\\n```typescript\\n// Add to AudioPlayerContext.tsx\\n\\n// Configuration constants\\nconst START_THRESHOLD_SECONDS = 30;\\nconst COMPLETION_THRESHOLD_PERCENT = 75;\\n\\n// Tracking state (reset per listening session)\\nconst sessionIdRef = useRef(null);\\nconst hasLoggedStartRef = useRef(false);\\nconst hasLoggedCompletionRef = useRef(false);\\nconst accumulatedListenTimeRef = useRef(0);\\nconst lastTimeUpdateRef = useRef(0);\\n\\n// Generate session ID when starting new track\\nconst startNewSession = () => {\\n  sessionIdRef.current = `${Date.now()}-${Math.random().toString(36).slice(2)}`;\\n  hasLoggedStartRef.current = false;\\n  hasLoggedCompletionRef.current = false;\\n  accumulatedListenTimeRef.current = 0;\\n  lastTimeUpdateRef.current = 0;\\n};\\n\\n// Track accumulated listening time during timeupdate events\\nconst handleTimeUpdate = (currentPosition: number) => {\\n  if (lastTimeUpdateRef.current > 0) {\\n    const delta = currentPosition - lastTimeUpdateRef.current;\\n    // Only count forward progress (<2s to filter seeks)\\n    if (delta > 0 && delta < 2) {\\n      accumulatedListenTimeRef.current += delta;\\n    }\\n  }\\n  lastTimeUpdateRef.current = currentPosition;\\n  \\n  // Check milestones\\n  checkEngagementMilestones(currentPosition);\\n};\\n\\n// Log engagement events\\nconst checkEngagementMilestones = async (currentPosition: number) => {\\n  if (!currentItem || !duration) return;\\n  \\n  const progressPercent = (currentPosition / (duration / 1000)) * 100;\\n  const audioType = currentItem.type === 'summary' ? 'summary' : 'full_episode';\\n  const masterBriefId = currentItem.type === 'summary' \\n    ? currentItem.masterBriefId \\n    : `episode-${currentItem.taddyEpisodeUuid}`;\\n  \\n  // Log START after 30 seconds accumulated listening\\n  if (!hasLoggedStartRef.current && accumulatedListenTimeRef.current >= START_THRESHOLD_SECONDS) {\\n    hasLoggedStartRef.current = true;\\n    \\n    await supabase.from('audio_engagement_events').insert({\\n      user_id: user.id,\\n      master_brief_id: masterBriefId,\\n      audio_type: audioType,\\n      event_type: 'start',\\n      duration_seconds: Math.round(duration / 1000),\\n      progress_seconds: Math.round(currentPosition),\\n      progress_percentage: Math.round(progressPercent * 100) / 100,\\n      session_id: sessionIdRef.current,\\n    });\\n  }\\n  \\n  // Log COMPLETION at 75% position\\n  if (!hasLoggedCompletionRef.current && progressPercent >= COMPLETION_THRESHOLD_PERCENT) {\\n    hasLoggedCompletionRef.current = true;\\n    \\n    await supabase.from('audio_engagement_events').insert({\\n      user_id: user.id,\\n      master_brief_id: masterBriefId,\\n      audio_type: audioType,\\n      event_type: 'completion',\\n      duration_seconds: Math.round(duration / 1000),\\n      progress_seconds: Math.round(currentPosition),\\n      progress_percentage: Math.round(progressPercent * 100) / 100,\\n      session_id: sessionIdRef.current,\\n    });\\n  }\\n};\\n\\n// Call startNewSession() when play() is called with a new item\\n// Call handleTimeUpdate() in your progress interval\\n```\\n\\n---\\n\\n### ðŸ”´ Critical: Summary Downloads Use Expired URLs\\n\\n**File:** `client/screens/LibraryScreen.tsx` (line ~441)\\n\\n**Problem:** `handleDownloadBrief` uses `brief.master_brief.audio_url` directly. This is a signed URL that expires in 15 minutes, making offline downloads fail.\\n\\n**Current (Broken):**\\n```typescript\\nconst response = await fetch(brief.master_brief.audio_url); // âŒ Expires!\\n```\\n\\n**Required Fix:**\\n```typescript\\nconst handleDownloadBrief = async (brief: UserBrief) => {\\n  // 1. Get a FRESH signed URL\\n  const { data, error } = await supabase.functions.invoke('get-signed-audio-url', {\\n    body: { masterBriefId: brief.master_brief_id },\\n  });\\n  \\n  if (error || !data?.signedUrl) {\\n    Alert.alert('Error', 'Failed to get download URL');\\n    return;\\n  }\\n  \\n  // 2. Download using the fresh URL\\n  const response = await fetch(data.signedUrl);\\n  // ... rest of download logic\\n};\\n```\\n\\n---\\n\\n### ðŸ”´ Critical: No Language Filtering on Briefs\\n\\n**File:** `client/screens/LibraryScreen.tsx` (line ~104)\\n\\n**Problem:** Mobile fetches ALL `user_briefs` regardless of language. Users will see briefs in wrong languages.\\n\\n**Current:**\\n```typescript\\n.eq('user_id', user.id)\\n.eq('is_hidden', false)\\n// Missing language filter!\\n```\\n\\n**Required Fix:**\\n```typescript\\nconst { data, error } = await supabase\\n  .from('user_briefs')\\n  .select(`\\n    *,\\n    master_brief:master_briefs!inner(\\n      id,\\n      language,\\n      ...\\n    )\\n  `)\\n  .eq('user_id', user.id)\\n  .eq('is_hidden', false)\\n  .eq('master_brief.language', profile?.preferred_language || 'en')  // â† ADD THIS\\n  .order('created_at', { ascending: false });\\n```\\n\\n**Note:** The `!inner` join syntax ensures only matching briefs are returned.\\n\\n---\\n\\n### ðŸ”´ Critical: No Database Progress Sync\\n\\n**File:** `client/contexts/AudioPlayerContext.tsx`\\n\\n**Problem:** Progress is saved only to AsyncStorage. When users switch devices, progress is lost.\\n\\n**Required: Sync to Supabase periodically**\\n\\n```typescript\\n// Add to saveProgress function or create separate syncProgress function\\nconst syncProgressToDatabase = async () => {\\n  if (!currentItem || !user) return;\\n  \\n  const progressSeconds = Math.floor(position / 1000);\\n  \\n  if (currentItem.type === 'summary' && currentItem.userBriefId) {\\n    await supabase\\n      .from('user_briefs')\\n      .update({ audio_progress_seconds: progressSeconds })\\n      .eq('id', currentItem.userBriefId);\\n  } else if (currentItem.type === 'episode' && currentItem.savedEpisodeId) {\\n    await supabase\\n      .from('saved_episodes')\\n      .update({ audio_progress_seconds: progressSeconds })\\n      .eq('id', currentItem.savedEpisodeId);\\n  }\\n};\\n\\n// Call every 10-15 seconds during playback\\nuseEffect(() => {\\n  if (!isPlaying) return;\\n  \\n  const interval = setInterval(() => {\\n    syncProgressToDatabase();\\n  }, 15000);\\n  \\n  return () => clearInterval(interval);\\n}, [isPlaying, currentItem, position]);\\n```\\n\\n---\\n\\n### ðŸ”´ Critical: No Auto-Complete on Playback End\\n\\n**File:** `client/contexts/AudioPlayerContext.tsx`\\n\\n**Problem:** Briefs/episodes are not marked as `is_completed: true` when playback finishes.\\n\\n**Required: Add to playback completion handler**\\n\\n```typescript\\n// When audio ends\\nconst handlePlaybackEnd = async () => {\\n  if (!currentItem || !user) return;\\n  \\n  if (currentItem.type === 'summary' && currentItem.masterBriefId) {\\n    // Mark brief as completed\\n    await supabase\\n      .from('user_briefs')\\n      .update({ is_completed: true })\\n      .eq('master_brief_id', currentItem.masterBriefId)\\n      .eq('user_id', user.id);\\n    \\n    // Invalidate query cache\\n    queryClient.invalidateQueries({ queryKey: ['userBriefs'] });\\n  } else if (currentItem.type === 'episode' && currentItem.savedEpisodeId) {\\n    // Mark episode as completed\\n    await supabase\\n      .from('saved_episodes')\\n      .update({ is_completed: true })\\n      .eq('id', currentItem.savedEpisodeId);\\n    \\n    queryClient.invalidateQueries({ queryKey: ['savedEpisodes'] });\\n  }\\n};\\n```\\n\\n---\\n\\n### ðŸŸ¡ Minor: Add Mobile Source to Analytics\\n\\n**All analytics inserts should include `source: 'mobile'` in metadata:**\\n\\n```typescript\\nawait supabase.from('analytics_events').insert({\\n  user_id: user.id,\\n  event_type: 'summary_generated',\\n  brief_id: masterBriefId,\\n  language: profile?.preferred_language,\\n  metadata: {\\n    source: 'mobile',  // â† ADD THIS\\n    platform: Platform.OS,  // 'ios' or 'android'\\n    // ... other metadata\\n  },\\n});\\n```\\n\\n---\\n\\n### ðŸŸ¡ Minor: Clean Up Replit Template Artifacts\\n\\n**Remove or update these files that reference Express/Replit patterns:**\\n\\n1. `client/lib/query-client.ts` - Uses Express-style fetch pattern, not needed with Supabase SDK\\n2. `shared/schema.ts` - Drizzle schema doesn't match Supabase schema\\n\\n---\\n\\n### Implementation Checklist\\n\\n| Issue | Priority | Estimated Effort |\\n|-------|----------|------------------|\\n| Add audio engagement tracking | ðŸ”´ Critical | 2-3 hours |\\n| Fix summary download URL | ðŸ”´ Critical | 30 minutes |\\n| Add language filter to briefs query | ðŸ”´ Critical | 15 minutes |\\n| Sync progress to database | ðŸ”´ Critical | 1 hour |\\n| Auto-complete on playback end | ðŸ”´ Critical | 30 minutes |\\n| Add mobile source to analytics | ðŸŸ¡ Minor | 15 minutes |\\n| Clean up Replit artifacts | ðŸŸ¡ Minor | 1 hour |\\n\\n---\\n\\n*Document generated for PodBrief Mobile App Development*\"}">

 âš ï¸ **Implementation Note:** See [Mobile Audit Findings](./Mobile_Integration_Guide.md#mobile-audit-findings--required-fixes) - the mobile app currently does NOT implement this tracking.\\n\\n```typescript\\n// Generate a unique session ID when starting a new track\\nconst sessionId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;\\n\\n// Track accumulated listening time, NOT just position\\n// Log START after 30 SECONDS OF ACCUMULATED LISTENING (not 30s position)\\nawait supabase.from('audio_engagement_events').insert({\\n  user_id: user.id,\\n  master_brief_id: briefId,        // For episodes: use `episode-${taddyEpisodeUuid}`\\n  audio_type: 'summary',           // 'summary' or 'full_episode'\\n  event_type: 'start',\\n  duration_seconds: totalDuration,\\n  progress_seconds: currentPosition,\\n  progress_percentage: Math.round((currentPosition / totalDuration) * 100),\\n  session_id: sessionId,           // REQUIRED: Used for deduplication\\n});\\n```\\n\\n**Log Audio Completion:**\\n\\n```typescript\\n// Log COMPLETION when user reaches 75% POSITION\\nawait supabase.from('audio_engagement_events').insert({\\n  user_id: user.id,\\n  master_brief_id: briefId,\\n  audio_type: 'summary',\\n  event_type: 'completion',\\n  duration_seconds: totalDuration,\\n  progress_seconds: currentPosition,\\n  progress_percentage: 75,\\n  session_id: sessionId,           // Same session ID as start event\\n});\\n```\\n\\n**Key Rules:**\\n- `start` event: Log after **30 seconds of accumulated listening** (track time elapsed while playing, not seeks)\\n- `completion` event: Log when position reaches **75%**\\n- Both events use the same `session_id` per track play session\\n- For full episodes, use `master_brief_id: 'episode-${taddyEpisodeUuid}'`\"}">

 Complete API reference for building iOS/Android apps that connect to the PodBrief backend.\\n\\n**Last Updated:** February 2, 2026  \\n**API Version:** 1.1\", \"first_replaced_line\": 1, \"last_replaced_line\": 6, \"replace\": \"# PodBrief Mobile API Contract\\n\\n> Complete API reference for building iOS/Android apps that connect to the PodBrief backend.\\n\\n**Last Updated:** February 2, 2026  \\n**API Version:** 1.2\\n\\n> âš ï¸ **IMPORTANT:** A code audit was performed on Feb 2, 2026. See [Mobile Audit Findings](./Mobile_Integration_Guide.md#mobile-audit-findings--required-fixes) for critical implementation gaps that need to be fixed.\"}">

I've audited the mobile app against the web implementation and updated both documentation files:

**Updated `docs/Mobile_API_Contract.md`:**
- Bumped version to 1.2
- Added audit warning banner at the top
- Enhanced audio engagement tracking docs with `session_id` and clearer rules

**Updated `docs/Mobile_Integration_Guide.md`:**  
- Added comprehensive "Mobile Audit Findings & Required Fixes" section with:
  - ðŸ”´ 5 critical issues with code examples
  - ðŸŸ¡ 2 minor issues
  - Implementation checklist with effort estimates

**Critical fixes needed in mobile app:**
1. **Add audio analytics tracking** - 2-3 hours
2. **Fix summary download URLs** - 30 min (use `get-signed-audio-url`)
3. **Add language filter to briefs query** - 15 min
4. **Sync progress to database** - 1 hour
5. **Auto-complete on playback end** - 30 min

Share the updated docs folder with your mobile team.

Document Native Google Sign-In flow
Create mobile testing checklist
Document Replit cleanup tasks